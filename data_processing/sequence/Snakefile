# snakemake --dryrun --printshellcmds --reason --jobs 1 --resources load=100
# snakemake --printshellcmds --reason --jobs "$(($(nproc --all) / 2))" --resources load=100

import os

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Define master rule (forces Snakemake to generate all missing files)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Replace with where you want to save output files
DATADIR = "../../data/"
# Replace with scratch space directory
WORKDIR = "../../data/tmp/"
# Replace with location of raw data generated by download_data
RAWDIR = "../../data/raw/"
fold_assignments = "../data_fold_assignments.csv"
FOLDS = 10

output = [
    os.path.join(DATADIR, f"k562_data_folds/k562_sequence_{fold}.npz")
    for fold in range(FOLDS)
]
output_fa = [
    os.path.join(DATADIR, f"k562_data_folds/k562_sequence_{fold}.fa.gz")
    for fold in range(FOLDS)
]
centered_fa = os.path.join(DATADIR, "k562_data_folds/k562_centered.fa.gz")


rule sequence_all:  # A master rule that ensures all the other rules run
    input:
        output,
        output_fa,
        centered_fa,
    params:
        WORKDIR,
    shell:
        "echo rm -r {params}"


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Get DNA sequence of windows
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


rule unpack_windows:
    input:
        shuf=os.path.join(DATADIR, "coords/procap_tss_1kb_windows.bed.gz"),
        cent=os.path.join(DATADIR, "coords/k562_procap_tss_1kb_centered_windows.bed.gz"),
    output:
        shuf=os.path.join(WORKDIR, "coords/procap_tss_1kb_windows.bed"),
        cent=os.path.join(WORKDIR, "coords/k562_procap_tss_1kb_centered_windows.bed"),
    shell:
        """
        gunzip -c {input.shuf} > {output.shuf}
        gunzip -c {input.cent} > {output.cent}
        """


rule get_window_sequences:
    input:
        fa=os.path.join(RAWDIR, "hg38.withrDNA.fa"),
        bed=os.path.join(WORKDIR, "coords/procap_tss_1kb_windows.bed"),
    output:
        os.path.join(WORKDIR, "sequence/k562_sequence.fa"),
    shell:
        "bedtools getfasta -fi {input.fa} -bed {input.bed} -fo {output}"


rule get_centered_window_sequences:
    input:
        fa=os.path.join(RAWDIR, "hg38.withrDNA.fa"),
        bed=os.path.join(WORKDIR, "coords/k562_procap_tss_1kb_centered_windows.bed"),
    output:
        centered_fa,
    shell:
        "bedtools getfasta -fi {input.fa} -bed {input.bed} | bgzip -c > {output}"


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Split sequence files into data folds
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


rule split_sequence:
    input:
        fa=os.path.join(WORKDIR, "sequence/k562_sequence.fa"),
    resources:
        load=1,
    params:
        fold_assignments=fold_assignments,
        fold="{fold}",
    output:
        fa=os.path.join(DATADIR, "k562_data_folds/k562_sequence_{fold}.fa.gz"),
    run:
        from Bio import SeqIO, bgzf
        import pandas as pd

        fold_assignments = pd.read_csv(
            params.fold_assignments, header=0, index_col=None
        )
        chroms = list(
            fold_assignments[fold_assignments["fold"] == int(params.fold)].chrom
        )

        recs = []
        with open(input.fa, "rt") as f:
            for rec in SeqIO.parse(f, "fasta"):
                chrom = rec.id.split(":")[0].split("_")[-1]
                if chrom in chroms:
                    recs.append(rec)

        with bgzf.BgzfWriter(output.fa, "wb") as out:
            SeqIO.write(recs, out, "fasta")


rule numpify_fasta:
    input:
        fa=os.path.join(DATADIR, "k562_data_folds/k562_sequence_{fold}.fa.gz"),
    output:
        npz=os.path.join(DATADIR, "k562_data_folds/k562_sequence_{fold}.npz"),
    run:
        import numpy as np
        import sys
        import pyfastx

        sys.path.append("../../model_training/")
        import utils

        seq_array = utils.get_twohot_fasta_sequences(input.fa, cores=1)
        np.savez_compressed(output.npz, seq_array)
